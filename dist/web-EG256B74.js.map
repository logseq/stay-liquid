{"version":3,"sources":["../src/components/tabs/web.ts","../src/components/tabs/color-utils.ts"],"sourcesContent":["import { WebPlugin } from \"@capacitor/core\";\nimport type {\n  TabsBarPlugin,\n  TabsBarConfigureOptions,\n  SelectOptions,\n  SetBadgeOptions,\n  SafeAreaInsets,\n  TabItem,\n  ImageIcon,\n  ImageLoadingState\n} from \"./definitions\";\nimport { isValidColor } from \"./color-utils\";\n\n/** Image cache for remote URLs */\ninterface CachedImage {\n  url: string;\n  blob: Blob;\n  timestamp: number;\n  objectUrl: string;\n}\n\n/** Image validation utilities */\nclass ImageValidator {\n  private static readonly SUPPORTED_FORMATS = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'image/webp'];\n  private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB\n  \n  static isValidImageFormat(contentType: string): boolean {\n    return this.SUPPORTED_FORMATS.includes(contentType.toLowerCase());\n  }\n  \n  static isValidBase64DataUri(dataUri: string): boolean {\n    const base64Pattern = /^data:image\\/(png|jpeg|jpg|svg\\+xml|webp);base64,/i;\n    return base64Pattern.test(dataUri);\n  }\n  \n  static isValidHttpUrl(url: string): boolean {\n    try {\n      const urlObj = new URL(url);\n      return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';\n    } catch {\n      return false;\n    }\n  }\n  \n  static validateImageSize(blob: Blob): boolean {\n    return blob.size <= this.MAX_FILE_SIZE;\n  }\n}\n\n/** Image loading and caching manager */\nclass ImageManager {\n  private static cache = new Map<string, CachedImage>();\n  private static readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n  private static loadingPromises = new Map<string, Promise<string>>();\n  \n  static async loadImage(imageIcon: ImageIcon): Promise<string> {\n    const { image } = imageIcon;\n    \n    // Handle base64 data URIs\n    if (ImageValidator.isValidBase64DataUri(image)) {\n      return image;\n    }\n    \n    // Handle remote URLs\n    if (ImageValidator.isValidHttpUrl(image)) {\n      return this.loadRemoteImage(image);\n    }\n    \n    throw new Error(`Invalid image source: ${image}`);\n  }\n  \n  private static async loadRemoteImage(url: string): Promise<string> {\n    // Check if already loading\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url)!;\n    }\n    \n    // Check cache first\n    const cached = this.cache.get(url);\n    if (cached && (Date.now() - cached.timestamp) < this.CACHE_DURATION) {\n      return cached.objectUrl;\n    }\n    \n    // Create loading promise\n    const loadingPromise = this.fetchAndCacheImage(url);\n    this.loadingPromises.set(url, loadingPromise);\n    \n    try {\n      const result = await loadingPromise;\n      this.loadingPromises.delete(url);\n      return result;\n    } catch (error) {\n      this.loadingPromises.delete(url);\n      throw error;\n    }\n  }\n  \n  private static async fetchAndCacheImage(url: string): Promise<string> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        mode: 'cors',\n        cache: 'default',\n        headers: {\n          'Accept': 'image/*'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const contentType = response.headers.get('content-type') || '';\n      if (!ImageValidator.isValidImageFormat(contentType)) {\n        throw new Error(`Unsupported image format: ${contentType}`);\n      }\n      \n      const blob = await response.blob();\n      if (!ImageValidator.validateImageSize(blob)) {\n        throw new Error('Image file too large');\n      }\n      \n      // Clean up old cache entry if exists\n      const oldCached = this.cache.get(url);\n      if (oldCached) {\n        URL.revokeObjectURL(oldCached.objectUrl);\n      }\n      \n      // Create new cache entry\n      const objectUrl = URL.createObjectURL(blob);\n      const cached: CachedImage = {\n        url,\n        blob,\n        timestamp: Date.now(),\n        objectUrl\n      };\n      \n      this.cache.set(url, cached);\n      \n      // Clean up old cache entries periodically\n      this.cleanupCache();\n      \n      return objectUrl;\n    } catch (error) {\n      throw new Error(`Failed to load image from ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  private static cleanupCache(): void {\n    const now = Date.now();\n    for (const [url, cached] of this.cache.entries()) {\n      if (now - cached.timestamp > this.CACHE_DURATION) {\n        URL.revokeObjectURL(cached.objectUrl);\n        this.cache.delete(url);\n      }\n    }\n  }\n  \n  static clearCache(): void {\n    for (const cached of this.cache.values()) {\n      URL.revokeObjectURL(cached.objectUrl);\n    }\n    this.cache.clear();\n    this.loadingPromises.clear();\n  }\n}\n\nexport class TabsBarWeb extends WebPlugin implements TabsBarPlugin {\n  private loadingStates = new Map<string, ImageLoadingState>();\n  private imageLoadPromises = new Map<string, Promise<void>>();\n  \n  async configure(options: TabsBarConfigureOptions): Promise<void> {\n    // Validate color options if provided\n    if (options.selectedIconColor && !isValidColor(options.selectedIconColor)) {\n      console.warn(`TabsBar: Invalid selectedIconColor format: ${options.selectedIconColor}`);\n    }\n    if (options.unselectedIconColor && !isValidColor(options.unselectedIconColor)) {\n      console.warn(`TabsBar: Invalid unselectedIconColor format: ${options.unselectedIconColor}`);\n    }\n    if (options.titleOpacity !== undefined && (options.titleOpacity < 0 || options.titleOpacity > 1)) {\n      console.warn(`TabsBar: titleOpacity must be between 0 and 1. Received: ${options.titleOpacity}`);\n    }\n    \n    // Validate and preload images\n    await this.validateAndPreloadImages(options.items);\n    \n    // Web implementation logs configuration for debugging\n    console.log('TabsBar configured with options:', {\n      itemCount: options.items.length,\n      initialId: options.initialId,\n      visible: options.visible,\n      hasSelectedColor: !!options.selectedIconColor,\n      hasUnselectedColor: !!options.unselectedIconColor,\n      titleOpacity: options.titleOpacity\n    });\n  }\n  \n  private async validateAndPreloadImages(items: TabItem[]): Promise<void> {\n    const imagePromises = items\n      .filter(item => item.imageIcon)\n      .map(item => this.preloadItemImage(item));\n    \n    await Promise.allSettled(imagePromises);\n  }\n  \n  private async preloadItemImage(item: TabItem): Promise<void> {\n    if (!item.imageIcon) return;\n    \n    const { id } = item;\n    const { imageIcon } = item;\n    \n    // Skip if already loading\n    if (this.imageLoadPromises.has(id)) {\n      return this.imageLoadPromises.get(id);\n    }\n    \n    this.loadingStates.set(id, 'loading');\n    \n    const loadPromise = this.loadImageIcon(imageIcon)\n      .then(() => {\n        this.loadingStates.set(id, 'loaded');\n        console.log(`TabsBar: Successfully loaded image for tab ${id}`);\n      })\n      .catch((error) => {\n        this.loadingStates.set(id, 'error');\n        console.warn(`TabsBar: Failed to load image for tab ${id}:`, error.message);\n        \n        // Fallback to system icon if available\n        if (item.systemIcon) {\n          console.log(`TabsBar: Using systemIcon fallback for tab ${id}: ${item.systemIcon}`);\n        } else {\n          console.warn(`TabsBar: No fallback available for tab ${id}`);\n        }\n      })\n      .finally(() => {\n        this.imageLoadPromises.delete(id);\n      });\n    \n    this.imageLoadPromises.set(id, loadPromise);\n    return loadPromise;\n  }\n  \n  private async loadImageIcon(imageIcon: ImageIcon): Promise<string> {\n    try {\n      return await ImageManager.loadImage(imageIcon);\n    } catch (error) {\n      throw new Error(`Image loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  /** Get the loading state of an image for a specific tab */\n  getImageLoadingState(tabId: string): ImageLoadingState | undefined {\n    return this.loadingStates.get(tabId);\n  }\n  \n  /** Clear all cached images */\n  clearImageCache(): void {\n    ImageManager.clearCache();\n    this.loadingStates.clear();\n    this.imageLoadPromises.clear();\n  }\n  \n  async show(): Promise<void> {\n    console.log('TabsBar: show() called');\n  }\n  \n  async hide(): Promise<void> {\n    console.log('TabsBar: hide() called');\n  }\n  \n  async select(options: SelectOptions): Promise<void> {\n    console.log('TabsBar: select() called with id:', options.id);\n  }\n  \n  async setBadge(options: SetBadgeOptions): Promise<void> {\n    console.log('TabsBar: setBadge() called with:', options);\n  }\n  \n  async getSafeAreaInsets(): Promise<SafeAreaInsets> {\n    return { top: 0, bottom: 0, left: 0, right: 0 };\n  }\n}\n","/**\n * Color validation utilities for TabsBar configuration\n */\n\n/**\n * Validates if a string is a valid hex color code\n * @param color - The color string to validate\n * @returns true if valid hex color, false otherwise\n */\nexport function isValidHexColor(color: string): boolean {\n  const hexRegex = /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;\n  return hexRegex.test(color);\n}\n\n/**\n * Validates if a string is a valid RGBA color code\n * @param color - The color string to validate\n * @returns true if valid RGBA color, false otherwise\n */\nexport function isValidRgbaColor(color: string): boolean {\n  const rgbaRegex = /^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i;\n  \n  const match = color.match(rgbaRegex);\n  if (!match) return false;\n  \n  const [, r, g, b, a] = match;\n  const red = parseFloat(r);\n  const green = parseFloat(g);\n  const blue = parseFloat(b);\n  const alpha = a ? parseFloat(a) : 1;\n  \n  return (\n    red >= 0 && red <= 255 &&\n    green >= 0 && green <= 255 &&\n    blue >= 0 && blue <= 255 &&\n    alpha >= 0 && alpha <= 1\n  );\n}\n\n/**\n * Validates if a string is a valid color (hex or RGBA)\n * @param color - The color string to validate\n * @returns true if valid color format, false otherwise\n */\nexport function isValidColor(color: string): boolean {\n  if (!color || typeof color !== 'string') return false;\n  return isValidHexColor(color) || isValidRgbaColor(color);\n}\n\n/**\n * Converts hex color to RGBA format\n * @param hex - Hex color string (e.g., \"#FF5733\" or \"#F57\")\n * @param alpha - Optional alpha value (0-1), defaults to 1\n * @returns RGBA color string or null if invalid hex\n */\nexport function hexToRgba(hex: string, alpha: number = 1): string | null {\n  if (!isValidHexColor(hex)) return null;\n  \n  // Remove # if present\n  hex = hex.replace('#', '');\n  \n  // Handle 3-digit hex\n  if (hex.length === 3) {\n    hex = hex.split('').map(char => char + char).join('');\n  }\n  \n  // Handle 8-digit hex (with alpha)\n  if (hex.length === 8) {\n    const alphaHex = hex.slice(6, 8);\n    alpha = parseInt(alphaHex, 16) / 255;\n    hex = hex.slice(0, 6);\n  }\n  \n  const r = parseInt(hex.slice(0, 2), 16);\n  const g = parseInt(hex.slice(2, 4), 16);\n  const b = parseInt(hex.slice(4, 6), 16);\n  \n  return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\n/**\n * Normalizes a color string to a consistent format for native processing\n * @param color - Color string in hex or RGBA format\n * @returns Normalized color object with r, g, b, a values (0-1 range) or null if invalid\n */\nexport function normalizeColor(color: string): { r: number; g: number; b: number; a: number } | null {\n  if (!color || typeof color !== 'string') return null;\n  \n  if (isValidHexColor(color)) {\n    const rgba = hexToRgba(color);\n    if (!rgba) return null;\n    color = rgba;\n  }\n  \n  if (isValidRgbaColor(color)) {\n    const match = color.match(/^rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*(?:,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/i);\n    if (!match) return null;\n    \n    const [, r, g, b, a] = match;\n    return {\n      r: parseFloat(r) / 255,\n      g: parseFloat(g) / 255,\n      b: parseFloat(b) / 255,\n      a: a ? parseFloat(a) : 1\n    };\n  }\n  \n  return null;\n}"],"mappings":"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","names":[]}